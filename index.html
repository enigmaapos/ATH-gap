<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/png" href="assets/logo.png">
  <title>Crypto Market Sentiment Analyzer — Robust</title>
  <style>
    body { font-family: system-ui, sans-serif; background:#0b0b0b; color:#e6eef6; margin:0; padding:20px; }
    .wrap{max-width:980px;margin:0 auto}
    h1 { color:#00bcd4; text-align:center; margin-bottom:6px; }
    .subtitle{ text-align:center;color:#9aa6b2;margin-bottom:18px }
    .card{ background:#0f1724; border-radius:10px; padding:14px; margin-bottom:14px; border:1px solid rgba(255,255,255,0.03) }
    .stats{ display:flex; gap:12px; justify-content:space-between; flex-wrap:wrap }
    .stat-item{ flex:1; min-width:180px }
    .stat-item strong{ display:block; color:#cfeeff; margin-bottom:6px }
    .sentiment{ text-align:center; padding:10px; border-radius:8px; font-weight:700; margin-top:10px }
    .bullish{ background:#033; color:#7ef1a6 }
    .neutral{ background:#333300; color:#fff29a }
    .bearish{ background:#300; color:#ff9b9b }
    .progress{ color:#9aa6b2; font-size:13px; margin-top:8px }
    table{ width:100%; border-collapse:collapse; margin-top:10px; font-size:13px }
    th,td{ padding:8px; border-bottom:1px solid rgba(255,255,255,0.03); text-align:left }
    th{ color:#74d0f1; font-weight:700 }
    tr:hover{ background: rgba(255,255,255,0.01) }
    .controls{ display:flex; gap:8px; align-items:center; justify-content:center; margin-bottom:12px; flex-wrap:wrap }
    button, select { padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:#071025; color:#e6eef6; cursor:pointer }
    .error{ color:#ffb4b4; margin-top:8px }
    footer{ text-align:center; color:#8897a8; margin-top:18px; font-size:13px }
    #phaseDisplay { padding:10px; border-radius:8px; text-align:center; font-weight:600; margin-top:10px; }
.phase-altseason { background:#002b1b; color:#90ffb0; }
.phase-transition { background:#332d00; color:#fff29a; }
.phase-correction { background:#331800; color:#ffc58a; }
.phase-capitulation { background:#330000; color:#ff9b9b; }
    /* 🪜 Phase Ladder Styles */
.phase-ladder {
  margin-top: 10px;
  text-align: center;
}
.ladder-track {
  position: relative;
  height: 8px;
  background: linear-gradient(to right, #800, #aa6200, #bba800, #007b3a);
  border-radius: 6px;
  overflow: hidden;
}
.ladder-bar {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 6%;
  background: rgba(255,255,255,0.8);
  border-radius: 6px;
  transition: left 0.8s ease;
}
.ladder-labels {
  display: flex;
  justify-content: space-between;
  margin-top: 4px;
  font-size: 12px;
  color: #bbb;
  }
/* 🧭 Footer Styles */
.footer {
  text-align: center;
  margin-top: 40px;
  padding-top: 16px;
  border-top: 1px solid rgba(255,255,255,0.05);
  color: #99a5b5;
  font-size: 13px;
  line-height: 1.6;
}
.footer a {
  color: #7cd8ff;
  text-decoration: none;
}
.footer a:hover {
  text-decoration: underline;
}
.footer-note {
  font-size: 12px;
  opacity: 0.8;
}
.footer-copy {
  font-size: 11px;
  margin-top: 4px;
  color: #777;
}
.brand {
  color: #00bcd4;
  font-weight: 600;
}
    @media (max-width:720px) { .stats { flex-direction:column; gap:10px } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>📊 Crypto Market Sentiment Analyzer — Robust</h1>
    <div class="subtitle">BTC vs Altcoins • Drawdown from ATH • Safe fetch + cache + retry</div>

    <div class="controls">
      <label>
        Sentiment scope:
        <select id="scopeSelect" title="Total coins used for sentiment calculation">
          <option value="250">Top 250</option>
          <option value="500">Top 500</option>
          <option value="750">Top 750</option>
          <option value="1000" selected>Top 1000</option>
        </select>
      </label>

      <label>
        TopN (tables source):
        <select id="displaySelect" title="Number of top coins used to build strongest/lagging tables">
          <option value="100" selected>Top 100</option>
          <option value="200">Top 200</option>
        </select>
      </label>

      <label>
        Refresh (sec):
        <select id="refreshSelect">
          <option value="60" selected>60</option>
          <option value="120">120</option>
          <option value="300">300</option>
        </select>
      </label>

      <button id="refreshNow">Refresh Now</button>
    </div>

    <div id="sentiment" class="sentiment neutral">Loading sentiment…</div>
      <div id="progressInfo" class="progress">Initializing…</div>
      <div id="errorMsg" class="error" style="display:none"></div>
  
    <hr class="my-3 border-slate-700" />

    <div id="mainCard" class="card">
      <div class="stats">
        <div class="stat-item">
          <strong>Bitcoin Drawdown</strong>
          <div id="btcGap">Loading…</div>
        </div>

        <div class="stat-item">
          <strong>Average Altcoin Drawdown</strong>
          <div id="altGap">Loading…</div>
        </div>

      
        <div class="stat-item">
          <strong>Altcoins Weakness Ratio</strong>
          <div id="ratio">Loading…</div>
        </div>
      </div>
      

        
      <div id="phaseDisplay" class="mt-3 p-2 rounded bg-black/20"></div>
      <!-- 🔰 Market Phase Ladder -->
<div id="phaseLadder" class="phase-ladder">
  <div class="ladder-track">
    <div id="ladderBar" class="ladder-bar"></div>
  </div>
  <div class="ladder-labels">
    <span>🔴 Bottom</span>
    <span>🟠 Correction</span>
    <span>🟡 Transition</span>
    <span>🟢 Altseason</span>
  </div>
</div>
    </div>

    <hr class="my-3 border-slate-700" />

    <div class="stat-item text-align:center">
          <strong>Dominant Group</strong>
          <div id="dominance">Loading…</div>
    </div>

    <hr class="my-3 border-slate-700" />


    <div class="card">
      
      <h3 style="color:#9ef5c6; text-align:center">📈 Top 10 Strongest (closest to ATH)</h3>
      <table id="topStrongest">
        <thead><tr><th>#</th><th>Coin</th><th>Symbol</th><th>Price</th><th>Drawdown</th></tr></thead>
        <tbody><tr><td colspan="5" style="text-align:center;color:#8c9db0">Loading…</td></tr></tbody>
      </table>
    </div>

    <div class="card">
      <h3 style="color:#ffb3b3; text-align:center">📉 Top 10 Lagging (farthest from ATH)</h3>
      <table id="topLagging">
        <thead><tr><th>#</th><th>Coin</th><th>Symbol</th><th>Price</th><th>Drawdown</th></tr></thead>
        <tbody><tr><td colspan="5" style="text-align:center;color:#8c9db0">Loading…</td></tr></tbody>
      </table>
    </div>

    <footer class="footer">
  <div>📊 <strong>Crypto Market Sentiment Analyzer</strong> — powered by <a href="https://www.coingecko.com" target="_blank" rel="noopener">CoinGecko</a></div>
  <div class="footer-note">Realtime client-side analysis • Smart cache + fallback • Built for research and market insights</div>
  <div class="footer-copy">© 2025 <span class="brand">WatchMe Analytics</span>. All rights reserved.</div>
</footer>
  </div>

<script>
/*
 Robust Sentiment Analyzer
 - safe fetch with timeout
 - uses cache in localStorage if fetch fails
 - avoids divide-by-zero and missing ATH issues
 - shows error messages and retry button
*/

const COINGECKO = '/api/coins';
const PER_PAGE = 250;            // max per page
const DEFAULT_DELAY = 1500;      // ms between page calls
const CACHE_KEY = 'cg_sentiment_cache_v1';
const CACHE_INFO_KEY = 'cg_sentiment_cache_info_v1';
const DEFAULT_REFRESH_MS = 60000;

let refreshTimer = null;

// UI elements
const btcGapEl = document.getElementById('btcGap');
const altGapEl = document.getElementById('altGap');
const ratioEl = document.getElementById('ratio');
const dominanceEl = document.getElementById('dominance');
const sentimentEl = document.getElementById('sentiment');
const progressInfoEl = document.getElementById('progressInfo');
const errorMsgEl = document.getElementById('errorMsg');
const topStrongestTbody = document.querySelector('#topStrongest tbody');
const topLaggingTbody = document.querySelector('#topLagging tbody');
const scopeSelect = document.getElementById('scopeSelect');
const displaySelect = document.getElementById('displaySelect');
const refreshSelect = document.getElementById('refreshSelect');
const refreshNowBtn = document.getElementById('refreshNow');

// helpers
const sleep = ms => new Promise(r => setTimeout(r, ms));
function setProgress(text){ progressInfoEl.textContent = text; }
function setError(msg){ errorMsgEl.style.display = msg ? 'block' : 'none'; errorMsgEl.textContent = msg || ''; }
function setSentimentUI(text, cls){ sentimentEl.textContent = text; sentimentEl.className = 'sentiment ' + cls; }

// 🔒 Safe cache helpers with timestamp tracking
function saveCache(data) {
  try {
    const cache = {
      data,
      timestamp: Date.now(), // record the exact cache time
    };
    localStorage.setItem('coinCache', JSON.stringify(cache));
  } catch (err) {
    console.warn('cache save error', err);
  }
}

function loadCache() {
  try {
    const cache = JSON.parse(localStorage.getItem('coinCache') || '{}');
    return cache;
  } catch (err) {
    console.error('Error reading cache:', err);
    return { data: [], timestamp: 0 };
  }
}

// fetch with timeout
async function fetchWithTimeout(url, timeout = 12000){
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), timeout);
  try{
    const res = await fetch(url, { signal: controller.signal });
    clearTimeout(id);
    return res;
  } catch (err) {
    clearTimeout(id);
    throw err;
  }
}

// top-level fetch pages safely with handling
async function fetchPages(totalCoins, delayMs = DEFAULT_DELAY){
  const pages = Math.ceil(totalCoins / PER_PAGE);
  let all = [];
  for (let p = 1; p <= pages; p++){
    setProgress(`Fetching page ${p}/${pages}...`);
    const url = `${COINGECKO}?page=${p}`;
    try {
      const res = await fetchWithTimeout(url, 12000);
      if (!res.ok){
        // if rate limited provide message and break to fallback
        const status = res.status;
        const text = await res.text().catch(()=>String(res.status));
        throw new Error(`HTTP ${status}: ${text}`);
      }
      const json = await res.json();
      if (!Array.isArray(json)) throw new Error('Unexpected JSON');
      all = all.concat(json);
    } catch (err) {
      // bubble error to caller with context
      err.message = `Error fetching page ${p}: ${err.message}`;
      throw err;
    }
    if (p < pages) await sleep(delayMs);
  }
  return all;
}

// compute gaps safely (only coins with valid ATH + price)
function computeGaps(coins){
  const byId = {}; // map for quick lookup if needed
  coins.forEach(c => byId[c.id] = c);

  // find btc robustly (prefer id 'bitcoin')
  let btc = coins.find(c => (c.id === 'bitcoin') || (c.symbol && c.symbol.toLowerCase() === 'btc'));
  if (!btc) {
    // fallback first coin
    btc = coins[0] || null;
  }

  // compute alt gaps (only for coins with valid numbers)
  const altGaps = coins
    .filter(c => c.id && c.current_price != null && c.ath != null && Number(c.ath) > 0 && c.id !== (btc && btc.id))
    .map(c => {
      const price = Number(c.current_price);
      const ath = Number(c.ath);
      const gap = (ath > 0) ? ((ath - price) / ath) * 100 : null;
      return { id: c.id, name: c.name, symbol: c.symbol, price, ath, gap, change24h: c.price_change_percentage_24h };
    })
    .filter(x => x.gap != null && Number.isFinite(x.gap));

  // btc gap
  let btcGap = null;
  if (btc && btc.ath != null && Number(btc.ath) > 0 && btc.current_price != null) {
    btcGap = ((Number(btc.ath) - Number(btc.current_price)) / Number(btc.ath)) * 100;
    if (!Number.isFinite(btcGap)) btcGap = null;
  }

  return { btc, btcGap, altGaps };
}

// ⚖️ Weighted & integrated sentiment computation
function deriveSentiment(btcGap, altGaps) {
  const safeBtcGap = (btcGap == null || btcGap <= 0) ? 0 : btcGap;
  const avgAltGap = altGaps.length
    ? (altGaps.reduce((s, x) => s + x.gap, 0) / altGaps.length)
    : null;

  // thresholds
  const STRONG_THRESHOLD = 70;  // <70% drawdown = strong
  const LAGGING_THRESHOLD = 90; // >90% drawdown = lagging

  const strongCount = altGaps.filter(x => x.gap < STRONG_THRESHOLD).length;
  const lagCount = altGaps.filter(x => x.gap > LAGGING_THRESHOLD).length;
  const total = altGaps.length || 1;

  // dominance ratio
  const dominanceRatio = strongCount / total;
  let dominance = 'Balanced';
  if (dominanceRatio > 0.55) dominance = 'Strong Coins Dominant';
  else if (dominanceRatio < 0.45) dominance = 'Lagging Coins Dominant';

  // weakness ratio
  let ratio = (!avgAltGap || safeBtcGap === 0)
    ? Number.POSITIVE_INFINITY
    : avgAltGap / safeBtcGap;

  // 🧮 Weighted integrated sentiment computation
  const btcScore = 1 - Math.min(safeBtcGap / 100, 1);
  const altScore = 1 - Math.min((avgAltGap || 100) / 100, 1);
  const dominanceScore = dominanceRatio;

  const sentimentScore =
    btcScore * 0.35 +
    altScore * 0.25 +
    dominanceScore * 0.40;

  // 🧭 Classification logic
  let sentiment, sentimentClass, sentimentEmoji;
  if (sentimentScore >= 0.70) {
    sentiment = 'Bullish'; sentimentClass = 'bullish'; sentimentEmoji = '🚀';
  } else if (sentimentScore >= 0.45) {
    sentiment = 'Neutral'; sentimentClass = 'neutral'; sentimentEmoji = '😐';
  } else {
    sentiment = 'Bearish'; sentimentClass = 'bearish'; sentimentEmoji = '🩸';
  }

  return {
    avgAltGap,
    ratio,
    dominance,
    strongCount,
    lagCount,
    sentiment,
    sentimentClass,
    sentimentEmoji,
    sentimentScore: sentimentScore.toFixed(3)
  };
}

function determineMarketPhase(btcGap, altGapAvg, awr, strongCount, lagCount) {
  let phase = "Neutral";
  let description = "";
  let insight = "";

  if (awr < 3 && btcGap < 15) {
    phase = "🟢 Altseason / Expansion";
    description = "Altcoins are outperforming Bitcoin. Strong risk-on momentum.";
    insight = "📈 Historically marks the mid-bull run where altcoins explode higher.";
  } 
  else if (awr >= 3 && awr <= 8 && btcGap < 25) {
    phase = "🟡 Transition / Caution";
    description = "Bitcoin is still leading, but altcoins are regaining traction. Watch for rotation.";
    insight = "⚖️ Often appears mid-cycle before either a correction or a renewed rally.";
  } 
  else if (awr > 8 && awr <= 15) {
    phase = "🟠 Correction / Rotation";
    description = "Liquidity is rotating back into Bitcoin or stablecoins. Market cautious.";
    insight = "🔁 Common before major shakeouts or after temporary overextension.";
  } 
  else if (awr > 15 && btcGap < 10) {
    phase = "🔴 Capitulation / Bottom";
    description = "Altcoins are extremely weak vs Bitcoin. Historically near market bottoms.";
    insight = "🪙 Historically, this phase often precedes recovery — smart money quietly accumulates strong altcoins.";
  } 
  else {
    phase = "Neutral";
    description = "Mixed sentiment — no clear leadership between BTC and altcoins.";
    insight = "🧭 Watch closely for upcoming shifts in BTC dominance or altcoin strength.";
  }

  const dominance = strongCount > lagCount ? "Strong Coins Dominant" : "Lagging Coins Dominant";

  return { phase, description, insight, dominance };
}
  

// helper to render top lists
function renderTopTables(displayList){
  const valid = displayList.filter(c => c.ath != null && c.current_price != null && Number(c.ath) > Number(c.current_price));
  const enriched = valid.map(c => {
    const price = Number(c.current_price), ath = Number(c.ath);
    const gap = ((ath - price) / ath) * 100;
    return { name: c.name, symbol: c.symbol.toUpperCase(), price, gap, change24h: c.price_change_percentage_24h };
  });

  const strongest = enriched.slice().sort((a,b)=>a.gap - b.gap).slice(0,10);
  const lagging = enriched.slice().sort((a,b)=>b.gap - a.gap).slice(0,10);

  // render strongest
  topStrongestTbody.innerHTML = '';
  if (strongest.length === 0) topStrongestTbody.innerHTML = `<tr><td colspan="5" style="text-align:center;color:#8c9db0">No data</td></tr>`;
  else strongest.forEach((s,i)=>{
    topStrongestTbody.insertAdjacentHTML('beforeend', `
      <tr>
        <td>${i+1}</td>
        <td>${s.name}</td>
        <td>${s.symbol}</td>
        <td>$${s.price.toLocaleString()}</td>
        <td>${s.gap.toFixed(2)}%</td>
      </tr>
    `);
  });

  // render lagging
  topLaggingTbody.innerHTML = '';
  if (lagging.length === 0) topLaggingTbody.innerHTML = `<tr><td colspan="5" style="text-align:center;color:#8c9db0">No data</td></tr>`;
  else lagging.forEach((s,i)=>{
    topLaggingTbody.insertAdjacentHTML('beforeend', `
      <tr>
        <td>${i+1}</td>
        <td>${s.name}</td>
        <td>${s.symbol}</td>
        <td>$${s.price.toLocaleString()}</td>
        <td>${s.gap.toFixed(2)}%</td>
      </tr>
    `);
  });
}

// main orchestrator
async function runAnalysis(forceFetch=false){
  setError('');
  const scope = Number(scopeSelect.value);      // coins used for sentiment (e.g., 1000)
  const displayN = Number(displaySelect.value); // coins used for tables (e.g., 200)
  const refreshSec = Number(refreshSelect.value);

  // update interval if changed
  clearInterval(refreshTimer);
  refreshTimer = setInterval(()=> runAnalysis(false), refreshSec * 1000);

  // check cache
  const cache = loadCache();
  const cacheValidMs = Math.max(30000, refreshSec * 1000 - 1000); // adaptive TTL
  const cachedTs = cache.info && cache.info.ts ? cache.info.ts : 0;
  const cacheAge = Date.now() - cachedTs;
  if (!forceFetch && cache.data && cache.data.length >= displayN && cacheAge < cacheValidMs){
    setProgress(`Using cached data (age ${(cacheAge/1000).toFixed(1)}s).`);
    try {
      // use cached for quick render then refresh in background
      const cached = cache.data;
      const sentimentCoins = cached.slice(0, scope);
      const displayCoins = cached.slice(0, displayN);
      const { btc, btcGap, altGaps } = computeGaps(sentimentCoins);
      const sentimentResults = deriveSentiment(btcGap, altGaps);
      
      // UI update
      updateUI(btc, btcGap, sentimentResults);
      renderTopTables(displayCoins);
      // continue to fetch in background to keep fresh
      fetchAndUpdate(scope, displayN, /*background*/true);
      return;
    } catch (err) {
      console.warn('cached render failed', err);
      // fallthrough to fetch
    }
  }

  // otherwise fetch live
  await fetchAndUpdate(scope, displayN, false);
}
// fetch and update with graceful fallback and cleaner messaging
async function fetchAndUpdate(scope, displayN, background = false) {
  setProgress('🔄 Connecting to CoinGecko...');

  try {
    // Try live data fetch
    const coins = await fetchPages(scope, DEFAULT_DELAY);
    if (!coins || !coins.length) throw new Error('No coin data returned');

    // Save to cache on success
    saveCache(coins);

    // Compute sentiment and update UI
    const sentimentCoins = coins.slice(0, scope);
    const displayCoins = coins.slice(0, displayN);
    const { btc, btcGap, altGaps } = computeGaps(sentimentCoins);
    const sentimentResults = deriveSentiment(btcGap, altGaps);

    updateUI(btc, btcGap, sentimentResults);
    renderTopTables(displayCoins);

    // Success message
    const now = new Date().toLocaleTimeString();
    setProgress(`✅ Analyzed ${coins.length} coins • Updated: ${now}`);
    clearError();

  } catch (err) {
    console.warn('⚠️ Live fetch failed:', err);

    // Try cached fallback
    const cache = loadCache();

    if (cache.data && cache.data.length) {
      const coins = cache.data;

      // Recompute sentiment using cached data
      const sentimentCoins = coins.slice(0, scope);
      const displayCoins = coins.slice(0, displayN);
      const { btc, btcGap, altGaps } = computeGaps(sentimentCoins);
      const sentimentResults = deriveSentiment(btcGap, altGaps);

      updateUI(btc, btcGap, sentimentResults);
      renderTopTables(displayCoins);

      // Gentle user message
      const cacheAge = cache.timestamp ? new Date(cache.timestamp).toLocaleTimeString() : 'unknown';
      setProgress(`⚙️ Using cached snapshot (last updated: ${cacheAge}).`);
      clearError(); // don’t display error text
    } else {
      // No cache available — show proper error
      console.error('❌ No cache found. Cannot display data.');
      setError('🚫 Live fetch failed and no cached data available.');
      setProgress('Error: Unable to retrieve data.');
    }
  }
  }

  function updatePhaseDisplay({ phase, description, insight, dominance }) {
  const el = document.getElementById("phaseDisplay");
  if (!el) return;

  // 🧭 decide background color by phase
  let cls = "";
  if (phase.includes("Altseason")) cls = "phase-altseason";
  else if (phase.includes("Transition")) cls = "phase-transition";
  else if (phase.includes("Correction")) cls = "phase-correction";
  else if (phase.includes("Capitulation")) cls = "phase-capitulation";
  else cls = "";

  // 🪄 animate fade + color update
  el.className = cls;
  el.style.opacity = 0;
  el.innerHTML = `
    <div class="text-lg font-bold mt-2">${phase}</div>
    <div class="text-sm opacity-80">${description}</div>
    <div class="text-xs opacity-60 mt-1">⚖️ ${dominance}</div>
    <div class="text-xs mt-2 italic opacity-70">${insight}</div>
  `;
  setTimeout(() => {
    el.style.transition = "opacity 400ms ease";
    el.style.opacity = 1;
  }, 20);
}

  // 🪜 Update ladder position based on ratio and BTC drawdown
function updatePhaseLadder(awr, btcGap) {
  const bar = document.getElementById('ladderBar');
  if (!bar) return;

  let leftPercent = 0;

  if (awr > 15 && btcGap < 10) leftPercent = 2;        // 🔴 Capitulation
  else if (awr > 8 && awr <= 15) leftPercent = 33;     // 🟠 Correction
  else if (awr >= 3 && awr <= 8) leftPercent = 66;     // 🟡 Transition
  else if (awr < 3 && btcGap < 15) leftPercent = 94;   // 🟢 Altseason
  else leftPercent = 50;                               // Neutral / Between

  bar.style.left = `${leftPercent}%`;
}

// update UI helper
function updateUI(btc, btcGap, sentimentResults){
  if (!btc || btcGap == null || !Number.isFinite(btcGap)){
    btcGapEl.textContent = 'N/A';
  } else {
    btcGapEl.textContent = `${btcGap.toFixed(2)}%`;
  }

  if (!sentimentResults.avgAltGap || !Number.isFinite(sentimentResults.avgAltGap)){
    altGapEl.textContent = 'N/A';
  } else {
    altGapEl.textContent = `${sentimentResults.avgAltGap.toFixed(2)}%`;
  }

  ratioEl.textContent = !Number.isFinite(sentimentResults.ratio) ? '∞' : `${sentimentResults.ratio.toFixed(2)}×`;
  dominanceEl.textContent = `${sentimentResults.dominance} (Strong:${sentimentResults.strongCount}, Lag:${sentimentResults.lagCount})`;
  setSentimentUI(`${sentimentResults.sentimentEmoji} Market Sentiment: ${sentimentResults.sentiment} (${sentimentResults.sentimentScore})`, sentimentResults.sentimentClass);

  // 🧭 Update market phase dynamically
  const phaseInfo = determineMarketPhase(
    btcGap,
    sentimentResults.avgAltGap,
    sentimentResults.ratio,
    sentimentResults.strongCount,
    sentimentResults.lagCount
  );
  updatePhaseDisplay(phaseInfo);
  updatePhaseLadder(sentimentResults.ratio, btcGap);
}

// wire controls
refreshNowBtn.addEventListener('click', ()=> { runAnalysis(true); });
scopeSelect.addEventListener('change', ()=> runAnalysis(true));
displaySelect.addEventListener('change', ()=> runAnalysis(true));
refreshSelect.addEventListener('change', ()=> {
  clearInterval(refreshTimer);
  const ms = Number(refreshSelect.value) * 1000;
  refreshTimer = setInterval(()=> runAnalysis(false), ms);
});

// initial run
runAnalysis(false);

// expose for debugging
window._sentiment_debug = {
  runAnalysis, fetchPages, computeGaps, deriveSentiment, loadCache, saveCache
};
</script>
</body>
</html>
