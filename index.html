<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/png" href="assets/logo.png">
  <title>Crypto Market Sentiment Analyzer — Robust</title>
  <style>
body{font-family:system-ui,sans-serif;background:#0b0b0b;color:#e6eef6;margin:0;padding:20px;}
.wrap{max-width:980px;margin:0 auto;}
h1{color:#00bcd4;text-align:center;margin-bottom:6px;}
.subtitle{text-align:center;color:#9aa6b2;margin-bottom:18px;}
.card{background:#0f1724;border-radius:10px;padding:14px;margin-bottom:14px;border:1px solid rgba(255,255,255,0.03);}
.stats{display:flex;gap:12px;justify-content:space-between;flex-wrap:wrap;}
.stat-item{flex:1;min-width:200px;text-align:center;padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);transition:all .3s ease;}
.stat-item:hover{background:rgba(0,255,255,0.05);transform:translateY(-2px);box-shadow:0 0 8px rgba(0,255,255,0.1);}
.stat-item strong{display:block;color:#74d0f1;font-weight:700;letter-spacing:.3px;margin-bottom:6px;}
.value{font-size:1.4rem;font-weight:700;color:#cfeeff;margin-top:4px;transition:transform .3s ease;}
.stat-item:hover .value{transform:scale(1.04);}
.interpret{font-size:13px;margin-top:6px;opacity:.9;}
.interpret.bullish,.bullish{color:#7ef1a6;background:rgba(0,80,0,0.3);}
.interpret.neutral,.neutral{color:#fff29a;background:rgba(90,80,0,0.3);}
.interpret.bearish,.bearish{color:#ff9b9b;background:rgba(80,0,0,0.3);}
.small-note{font-size:12px;opacity:.7;color:#8aa6c9;}
.sentiment{text-align:center;padding:10px;border-radius:8px;font-weight:700;margin-top:10px;}
#phaseDisplay{padding:10px;border-radius:8px;text-align:center;font-weight:600;margin-top:10px;}
.phase-altseason{background:#002b1b;color:#90ffb0;}
.phase-transition{background:#332d00;color:#fff29a;}
.phase-correction{background:#331800;color:#ffc58a;}
.phase-capitulation{background:#330000;color:#ff9b9b;}
.phase-ladder{margin-top:10px;text-align:center;}
.ladder-track{position:relative;height:8px;background:linear-gradient(to right,#800,#aa6200,#bba800,#007b3a);border-radius:6px;overflow:hidden;}
.ladder-bar{position:absolute;top:0;left:0;height:100%;width:6%;background:rgba(255,255,255,0.8);border-radius:6px;transition:left .8s ease;}
.ladder-labels{display:flex;justify-content:space-between;margin-top:4px;font-size:12px;color:#bbb;}
.progress{color:#9aa6b2;font-size:13px;margin-top:8px;}
.error{color:#ffb4b4;margin-top:8px;}
table{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px;}
th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left;}
th{color:#74d0f1;font-weight:700;}
tr:hover{background:rgba(255,255,255,0.01);}
.controls{display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:12px;flex-wrap:wrap;}
button,select{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#071025;color:#e6eef6;cursor:pointer;}
.highlight{border:1px solid rgba(0,188,212,0.2);box-shadow:0 0 6px rgba(0,188,212,0.05);}
.footer{text-align:center;margin-top:40px;padding-top:16px;border-top:1px solid rgba(255,255,255,0.05);color:#a5b2c2;font-size:13px;line-height:1.6;}
.footer a{color:#00bcd4;text-decoration:none;}
.footer a:hover{text-decoration:underline;}
.footer-note{font-size:12px;opacity:.8;}
.footer-copy{font-size:11px;margin-top:4px;opacity:.6;}
.brand{color:#00bcd4;font-weight:600;}
@media(max-width:720px){.stats{flex-direction:column;gap:10px;}}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>📊 Crypto Market Sentiment Analyzer — Robust</h1>
    <div class="subtitle">BTC vs Altcoins • Drawdown from ATH • Safe fetch + cache + retry</div>

    <div class="controls">
      <label>
        Sentiment scope:
        <select id="scopeSelect" title="Total coins used for sentiment calculation">
          <option value="250">Top 250</option>
          <option value="500">Top 500</option>
          <option value="750">Top 750</option>
          <option value="1000" selected>Top 1000</option>
        </select>
      </label>

      <label>
        TopN (tables source):
        <select id="displaySelect" title="Number of top coins used to build strongest/lagging tables">
          <option value="100" selected>Top 100</option>
          <option value="200">Top 200</option>
        </select>
      </label>

      <label>
        Refresh (sec):
        <select id="refreshSelect">
          <option value="60" selected>60</option>
          <option value="120">120</option>
          <option value="300">300</option>
        </select>
      </label>

      <button id="refreshNow">Refresh Now</button>
    </div>

  <div class="wrap">

  <!-- 🧭 Sentiment + System Info -->
  <div id="sentiment" class="sentiment neutral">Loading sentiment…</div>
  <div id="progressInfo" class="progress">Initializing…</div>
  <div id="errorMsg" class="error" style="display:none"></div>

  <div class="card">
    <div class="stats">
      <div class="stat-item highlight">
        <strong>Bitcoin Dominance</strong>
        <div id="btcDominance" class="value">Loading…</div>
        <div id="btcDomInterpret" class="interpret">—</div>
      </div>

      <div class="stat-item highlight">
        <strong>Bitcoin Drawdown</strong>
        <div id="btcGap" class="value">Loading…</div>
        <div id="btcInterpret" class="interpret">—</div>
      </div>

      <div class="stat-item highlight">
        <strong>Average Altcoin Drawdown</strong>
        <div id="altGap" class="value">Loading…</div>
        <div id="altInterpret" class="interpret">—</div>
      </div>

      <div class="stat-item highlight">
  <strong>Altcoins Weakness Ratio</strong>
  <div id="ratio" class="value">Loading…</div>
  <div id="ratioPhase" class="interpret">—</div>
  <div class="interpret small-note">Lower = Altseason Potential</div>
</div>
    </div>

    <!-- 🪜 Market Phase Display -->
    <div id="phaseDisplay" class="mt-3 p-2 rounded bg-black/20"></div>
    <div id="phaseLadder" class="phase-ladder">
      <div class="ladder-track">
        <div id="ladderBar" class="ladder-bar"></div>
      </div>
      <div class="ladder-labels">
        <span>🔴 Bottom</span>
        <span>🟠 Correction</span>
        <span>🟡 Transition</span>
        <span>🟢 Altseason</span>
      </div>
    </div>

    <!-- ⚖️ Dominance Overview -->
    <div class="stat-item highlight" style="margin-top:16px;">
      <strong>Dominant Group</strong>
      <div id="dominance" class="value">Loading…</div>
    </div>
  </div>

  <!-- 📈 Top Performing Coins -->
  <div class="card">
    <h3 style="color:#9ef5c6; text-align:center;">📈 Top 10 Strongest (closest to ATH)</h3>
    <table id="topStrongest">
      <thead>
        <tr><th>#</th><th>Coin</th><th>Symbol</th><th>Price</th><th>Drawdown</th></tr>
      </thead>
      <tbody>
        <tr><td colspan="5" style="text-align:center;color:#8c9db0">Loading…</td></tr>
      </tbody>
    </table>
  </div>

  <!-- 📉 Lagging Coins -->
  <div class="card">
    <h3 style="color:#ffb3b3; text-align:center;">📉 Top 10 Lagging (farthest from ATH)</h3>
    <table id="topLagging">
      <thead>
        <tr><th>#</th><th>Coin</th><th>Symbol</th><th>Price</th><th>Drawdown</th></tr>
      </thead>
      <tbody>
        <tr><td colspan="5" style="text-align:center;color:#8c9db0">Loading…</td></tr>
      </tbody>
    </table>
  </div>

  <!-- 🧭 Footer -->
  <footer class="footer">
    <div>📊 <strong>Crypto Market Sentiment Analyzer</strong> — powered by <a href="https://www.coingecko.com" target="_blank" rel="noopener">CoinGecko</a></div>
    <div class="footer-note">Realtime client-side analysis • Smart cache + fallback • Built for research and market insights</div>
    <div class="footer-copy">© 2025 <span class="brand">WatchMe Analytics</span>. All rights reserved.</div>
  </footer>

  </div>

<script>
/*
 Robust Sentiment Analyzer
 - safe fetch with timeout
 - uses cache in localStorage if fetch fails
 - avoids divide-by-zero and missing ATH issues
 - shows error messages and retry button
*/

const COINGECKO = '/api/coins';
const PER_PAGE = 250;            // max per page
const DEFAULT_DELAY = 1500;      // ms between page calls
const CACHE_KEY = 'cg_sentiment_cache_v1';
const CACHE_INFO_KEY = 'cg_sentiment_cache_info_v1';
const DEFAULT_REFRESH_MS = 60000;

let refreshTimer = null;

// UI elements
const btcGapEl = document.getElementById('btcGap');
const altGapEl = document.getElementById('altGap');
const ratioEl = document.getElementById('ratio');
const dominanceEl = document.getElementById('dominance');
const sentimentEl = document.getElementById('sentiment');
const progressInfoEl = document.getElementById('progressInfo');
const errorMsgEl = document.getElementById('errorMsg');
const topStrongestTbody = document.querySelector('#topStrongest tbody');
const topLaggingTbody = document.querySelector('#topLagging tbody');
const scopeSelect = document.getElementById('scopeSelect');
const displaySelect = document.getElementById('displaySelect');
const refreshSelect = document.getElementById('refreshSelect');
const refreshNowBtn = document.getElementById('refreshNow');

// helpers
const sleep = ms => new Promise(r => setTimeout(r, ms));
function setProgress(text){ progressInfoEl.textContent = text; }
function setError(msg){ errorMsgEl.style.display = msg ? 'block' : 'none'; errorMsgEl.textContent = msg || ''; }
function setSentimentUI(text, cls){ sentimentEl.textContent = text; sentimentEl.className = 'sentiment ' + cls; }
  function clearError() {
  const el = document.getElementById('error');
  if (el) el.textContent = '';
  }

// 🔒 Safe cache helpers with timestamp tracking
function saveCache(data) {
  try {
    const cache = {
      data,
      timestamp: Date.now(), // record the exact cache time
    };
    localStorage.setItem('coinCache', JSON.stringify(cache));
  } catch (err) {
    console.warn('cache save error', err);
  }
}

function loadCache() {
  try {
    const cache = JSON.parse(localStorage.getItem('coinCache') || '{}');
    return cache;
  } catch (err) {
    console.error('Error reading cache:', err);
    return { data: [], timestamp: 0 };
  }
}

// fetch with timeout
async function fetchWithTimeout(url, timeout = 12000){
  const controller = new AbortController();
  const id = setTimeout(()=>controller.abort(), timeout);
  try{
    const res = await fetch(url, { signal: controller.signal });
    clearTimeout(id);
    return res;
  } catch (err) {
    clearTimeout(id);
    throw err;
  }
}

// top-level fetch pages safely with handling
async function fetchPages(totalCoins, delayMs = DEFAULT_DELAY){
  const pages = Math.ceil(totalCoins / PER_PAGE);
  let all = [];
  for (let p = 1; p <= pages; p++){
    setProgress(`Fetching page ${p}/${pages}...`);
    const url = `${COINGECKO}?page=${p}`;
    try {
      const res = await fetchWithTimeout(url, 12000);
      if (!res.ok){
        // if rate limited provide message and break to fallback
        const status = res.status;
        const text = await res.text().catch(()=>String(res.status));
        throw new Error(`HTTP ${status}: ${text}`);
      }
      const json = await res.json();
      if (!Array.isArray(json)) throw new Error('Unexpected JSON');
      all = all.concat(json);
    } catch (err) {
      // bubble error to caller with context
      err.message = `Error fetching page ${p}: ${err.message}`;
      throw err;
    }
    if (p < pages) await sleep(delayMs);
  }
  return all;
}

// compute gaps safely (only coins with valid ATH + price)
function computeGaps(coins){
  const byId = {}; // map for quick lookup if needed
  coins.forEach(c => byId[c.id] = c);

  // find btc robustly (prefer id 'bitcoin')
  let btc = coins.find(c => (c.id === 'bitcoin') || (c.symbol && c.symbol.toLowerCase() === 'btc'));
  if (!btc) {
    // fallback first coin
    btc = coins[0] || null;
  }

  // compute alt gaps (only for coins with valid numbers)
  const altGaps = coins
    .filter(c => c.id && c.current_price != null && c.ath != null && Number(c.ath) > 0 && c.id !== (btc && btc.id))
    .map(c => {
      const price = Number(c.current_price);
      const ath = Number(c.ath);
      const gap = (ath > 0) ? ((ath - price) / ath) * 100 : null;
      return { id: c.id, name: c.name, symbol: c.symbol, price, ath, gap, change24h: c.price_change_percentage_24h };
    })
    .filter(x => x.gap != null && Number.isFinite(x.gap));

  // btc gap
  let btcGap = null;
  if (btc && btc.ath != null && Number(btc.ath) > 0 && btc.current_price != null) {
    btcGap = ((Number(btc.ath) - Number(btc.current_price)) / Number(btc.ath)) * 100;
    if (!Number.isFinite(btcGap)) btcGap = null;
  }

  return { btc, btcGap, altGaps };
}

// ⚖️ Weighted & integrated sentiment computation
function deriveSentiment(btcGap, altGaps) {
  const safeBtcGap = (btcGap == null || btcGap <= 0) ? 0 : btcGap;
  const avgAltGap = altGaps.length
    ? (altGaps.reduce((s, x) => s + x.gap, 0) / altGaps.length)
    : null;

  // thresholds
  const STRONG_THRESHOLD = 70;  // <70% drawdown = strong
  const LAGGING_THRESHOLD = 90; // >90% drawdown = lagging

  const strongCount = altGaps.filter(x => x.gap < STRONG_THRESHOLD).length;
  const lagCount = altGaps.filter(x => x.gap > LAGGING_THRESHOLD).length;
  const total = altGaps.length || 1;

  // dominance ratio
  const dominanceRatio = strongCount / total;
  let dominance = 'Balanced';
  if (dominanceRatio > 0.55) dominance = 'Strong Coins Dominant';
  else if (dominanceRatio < 0.45) dominance = 'Lagging Coins Dominant';

  // weakness ratio
  let ratio = (!avgAltGap || safeBtcGap === 0)
    ? Number.POSITIVE_INFINITY
    : avgAltGap / safeBtcGap;

  // 🧮 Weighted integrated sentiment computation
  const btcScore = 1 - Math.min(safeBtcGap / 100, 1);
  const altScore = 1 - Math.min((avgAltGap || 100) / 100, 1);
  const dominanceScore = dominanceRatio;

  const sentimentScore =
    btcScore * 0.35 +
    altScore * 0.25 +
    dominanceScore * 0.40;

  // 🧭 Classification logic
  let sentiment, sentimentClass, sentimentEmoji;
  if (sentimentScore >= 0.70) {
    sentiment = 'Bullish'; sentimentClass = 'bullish'; sentimentEmoji = '🚀';
  } else if (sentimentScore >= 0.45) {
    sentiment = 'Neutral'; sentimentClass = 'neutral'; sentimentEmoji = '😐';
  } else {
    sentiment = 'Bearish'; sentimentClass = 'bearish'; sentimentEmoji = '🩸';
  }

  return {
    avgAltGap,
    ratio,
    dominance,
    strongCount,
    lagCount,
    sentiment,
    sentimentClass,
    sentimentEmoji,
    sentimentScore: sentimentScore.toFixed(3)
  };
}

function determineMarketPhase(btcGap, altGapAvg, awr, strongCount, lagCount) {
  let phase = "Neutral";
  let description = "";
  let insight = "";

  if (awr < 3 && btcGap < 15) {
    phase = "🟢 Altseason / Expansion";
    description = "Altcoins are outperforming Bitcoin. Strong risk-on momentum.";
    insight = "📈 Historically marks the mid-bull run where altcoins explode higher.";
  } 
  else if (awr >= 3 && awr <= 8 && btcGap < 25) {
    phase = "🟡 Transition / Caution";
    description = "Bitcoin is still leading, but altcoins are regaining traction. Watch for rotation.";
    insight = "⚖️ Often appears mid-cycle before either a correction or a renewed rally.";
  } 
  else if (awr > 8 && awr <= 15) {
    phase = "🟠 Correction / Rotation";
    description = "Liquidity is rotating back into Bitcoin or stablecoins. Market cautious.";
    insight = "🔁 Common before major shakeouts or after temporary overextension.";
  } 
  else if (awr > 15 && btcGap < 10) {
    phase = "🔴 Capitulation / Bottom";
    description = "Altcoins are extremely weak vs Bitcoin. Historically near market bottoms.";
    insight = "🪙 Historically, this phase often precedes recovery — smart money quietly accumulates strong altcoins.";
  } 
  else {
    phase = "Neutral";
    description = "Mixed sentiment — no clear leadership between BTC and altcoins.";
    insight = "🧭 Watch closely for upcoming shifts in BTC dominance or altcoin strength.";
  }

  const dominance = strongCount > lagCount ? "Strong Coins Dominant" : "Lagging Coins Dominant";

  return { phase, description, insight, dominance };
}
  

// helper to render top lists
function renderTopTables(displayList) {
  // 🧠 Exclude stablecoins, wrapped assets, staking derivatives, and LP tokens
  const excludedWords = [
    'usd', 'usdt', 'usdc', 'usde', 'dai', 'tether', 'busd', 'c1usd', 'usd1', 'susd', 'stable', 'peg', 'fiat',
    'wrapped', 'staked', 'restaked', 'liquid staking', 'lbtc', 'reth', 'seth', 'oseth', 'rsETH', 'lp', 'liquidity provider',
    'bond', 'derivative', 'index', 'yield'
  ];

  const valid = displayList.filter(c => {
    const name = (c.name || '').toLowerCase();
    const symbol = (c.symbol || '').toLowerCase();
    const ath = Number(c.ath);
    const price = Number(c.current_price);

    // Skip excluded tokens
    const isExcluded = excludedWords.some(w => name.includes(w) || symbol.includes(w));
    if (isExcluded) return false;

    // Only valid price and ATH
    return ath > 0 && price > 0 && ath > price;
  });

  // 🧮 Compute drawdowns for valid coins
  const enriched = valid.map(c => {
    const price = Number(c.current_price);
    const ath = Number(c.ath);
    const gap = ((ath - price) / ath) * 100;
    return {
      name: c.name,
      symbol: c.symbol.toUpperCase(),
      price,
      gap,
      change24h: c.price_change_percentage_24h
    };
  });

  // 🏆 Sort and pick top 10
  const strongest = enriched.slice().sort((a, b) => a.gap - b.gap).slice(0, 10);
  const lagging = enriched.slice().sort((a, b) => b.gap - a.gap).slice(0, 10);
  
  // render strongest
  topStrongestTbody.innerHTML = '';
  if (strongest.length === 0) topStrongestTbody.innerHTML = `<tr><td colspan="5" style="text-align:center;color:#8c9db0">No data</td></tr>`;
  else strongest.forEach((s,i)=>{
    topStrongestTbody.insertAdjacentHTML('beforeend', `
      <tr>
        <td>${i+1}</td>
        <td>${s.name}</td>
        <td>${s.symbol}</td>
        <td>$${s.price.toLocaleString()}</td>
        <td>${s.gap.toFixed(2)}%</td>
      </tr>
    `);
  });

  // render lagging
  topLaggingTbody.innerHTML = '';
  if (lagging.length === 0) topLaggingTbody.innerHTML = `<tr><td colspan="5" style="text-align:center;color:#8c9db0">No data</td></tr>`;
  else lagging.forEach((s,i)=>{
    topLaggingTbody.insertAdjacentHTML('beforeend', `
      <tr>
        <td>${i+1}</td>
        <td>${s.name}</td>
        <td>${s.symbol}</td>
        <td>$${s.price.toLocaleString()}</td>
        <td>${s.gap.toFixed(2)}%</td>
      </tr>
    `);
  });
}

// main orchestrator
async function runAnalysis(forceFetch=false){
  setError('');
  const scope = Number(scopeSelect.value);      // coins used for sentiment (e.g., 1000)
  const displayN = Number(displaySelect.value); // coins used for tables (e.g., 200)
  const refreshSec = Number(refreshSelect.value);

  // update interval if changed
  clearInterval(refreshTimer);
  refreshTimer = setInterval(()=> runAnalysis(false), refreshSec * 1000);

  // check cache
  const cache = loadCache();
  const cacheValidMs = Math.max(30000, refreshSec * 1000 - 1000); // adaptive TTL
  const cachedTs = cache.info && cache.info.ts ? cache.info.ts : 0;
  const cacheAge = Date.now() - cachedTs;
  if (!forceFetch && cache.data && cache.data.length >= displayN && cacheAge < cacheValidMs){
    setProgress(`Using cached data (age ${(cacheAge/1000).toFixed(1)}s).`);
    try {
      // use cached for quick render then refresh in background
      const cached = cache.data;
      const sentimentCoins = cached.slice(0, scope);
      const displayCoins = cached.slice(0, displayN);
      const { btc, btcGap, altGaps } = computeGaps(sentimentCoins);
      const sentimentResults = deriveSentiment(btcGap, altGaps);
      
      // UI update
      updateUI(btc, btcGap, sentimentResults);
      renderTopTables(displayCoins);
      
      // continue to fetch in background to keep fresh
      fetchAndUpdate(scope, displayN, /*background*/true);
      return;
    } catch (err) {
      console.warn('cached render failed', err);
      // fallthrough to fetch
    }
  }

  // otherwise fetch live
  await fetchAndUpdate(scope, displayN, false);
}
  
// fetch and update with graceful fallback and cleaner messaging
async function fetchAndUpdate(scope, displayN, background = false) {
  setProgress('🔄 Connecting to CoinGecko...');

  try {
    // Try live data fetch
    const coins = await fetchPages(scope, DEFAULT_DELAY);
    if (!coins || !coins.length) throw new Error('No coin data returned');

    // Save to cache on success
    saveCache(coins);

    // Compute sentiment and update UI
    const sentimentCoins = coins.slice(0, scope);
    const displayCoins = coins.slice(0, displayN);
    const { btc, btcGap, altGaps } = computeGaps(sentimentCoins);
    const sentimentResults = deriveSentiment(btcGap, altGaps);

    updateUI(btc, btcGap, sentimentResults);
    renderTopTables(displayCoins);

    // Success message
    const now = new Date().toLocaleTimeString();
    setProgress(`✅ Analyzed ${coins.length} coins • Updated: ${now}`);
    clearError();

  } catch (err) {
    console.warn('⚠️ Live fetch failed:', err);

    // Try cached fallback
    const cache = loadCache();

    if (cache.data && cache.data.length) {
      const coins = cache.data;

      // Recompute sentiment using cached data
      const sentimentCoins = coins.slice(0, scope);
      const displayCoins = coins.slice(0, displayN);
      const { btc, btcGap, altGaps } = computeGaps(sentimentCoins);
      const sentimentResults = deriveSentiment(btcGap, altGaps);

      updateUI(btc, btcGap, sentimentResults);
      renderTopTables(displayCoins);

      // Gentle user message
      const cacheAge = cache.timestamp ? new Date(cache.timestamp).toLocaleTimeString() : 'unknown';
      setProgress(`⚙️ Using cached snapshot (last updated: ${cacheAge}).`);
      clearError(); // don’t display error text
    } else {
      // No cache available — show proper error
      console.error('❌ No cache found. Cannot display data.');
      setError('🚫 Live fetch failed and no cached data available.');
      setProgress('Error: Unable to retrieve data.');
    }
  }
  }

  function updatePhaseDisplay({ phase, description, insight, dominance }) {
  const el = document.getElementById("phaseDisplay");
  if (!el) return;

  // 🧭 decide background color by phase
  let cls = "";
  if (phase.includes("Altseason")) cls = "phase-altseason";
  else if (phase.includes("Transition")) cls = "phase-transition";
  else if (phase.includes("Correction")) cls = "phase-correction";
  else if (phase.includes("Capitulation")) cls = "phase-capitulation";
  else cls = "";

  // 🪄 animate fade + color update
  el.className = cls;
  el.style.opacity = 0;
  el.innerHTML = `
    <div class="text-lg font-bold mt-2">${phase}</div>
    <div class="text-sm opacity-80">${description}</div>
    <div class="text-xs opacity-60 mt-1">⚖️ ${dominance}</div>
    <div class="text-xs mt-2 italic opacity-70">${insight}</div>
  `;
  setTimeout(() => {
    el.style.transition = "opacity 400ms ease";
    el.style.opacity = 1;
  }, 20);
}

  // 🪜 Update ladder position based on ratio and BTC drawdown
function updatePhaseLadder(awr, btcGap) {
  const bar = document.getElementById('ladderBar');
  if (!bar) return;

  let leftPercent = 0;

  if (awr > 15 && btcGap < 10) leftPercent = 2;        // 🔴 Capitulation
  else if (awr > 8 && awr <= 15) leftPercent = 33;     // 🟠 Correction
  else if (awr >= 3 && awr <= 8) leftPercent = 66;     // 🟡 Transition
  else if (awr < 3 && btcGap < 15) leftPercent = 94;   // 🟢 Altseason
  else leftPercent = 50;                               // Neutral / Between

  bar.style.left = `${leftPercent}%`;
}

  async function fetchBTCdominance() {
  try {
    const res = await fetch("/api/btc-dominance");
    const data = await res.json();
    const dominance = data.data.market_cap_percentage.btc;
    return dominance;
  } catch (err) {
    console.error("Error fetching BTC dominance:", err);
    return null;
  }
  }

// update UI helper
async function updateUI(btc, btcGap, sentimentResults) {
  const btcGapEl = document.getElementById('btcGap');
  const altGapEl = document.getElementById('altGap');
  const ratioEl = document.getElementById('ratio');
  const dominanceEl = document.getElementById('dominance');
  const btcInterpretEl = document.getElementById('btcInterpret');
  const altInterpretEl = document.getElementById('altInterpret');
  const btcDomEl = document.getElementById("btcDominance");
  const btcDomInterpret = document.getElementById("btcDomInterpret");

  // ✅ Bitcoin
  if (!btc || btcGap == null || !Number.isFinite(btcGap)) {
    btcGapEl.textContent = 'N/A';
    btcInterpretEl.textContent = '';
  } else {
    btcGapEl.textContent = `${btcGap.toFixed(2)}%`;
    let btcLabel = '';
    if (btcGap <= 5) btcLabel = '🔥 Near ATH / Euphoric Zone';
    else if (btcGap <= 15) btcLabel = '🟢 Minor Correction / Strong';
    else if (btcGap <= 35) btcLabel = '🟡 Mid Correction / Neutral';
    else if (btcGap <= 60) btcLabel = '🟠 Deep Correction / Watch Support';
    else btcLabel = '🔴 Capitulation / Bearish Zone';

    btcInterpretEl.textContent = btcLabel;
    btcInterpretEl.className =
      'interpret ' + (btcGap <= 15 ? 'bullish' : btcGap <= 60 ? 'neutral' : 'bearish');
  }

  // ✅ Altcoins
  if (!sentimentResults.avgAltGap || !Number.isFinite(sentimentResults.avgAltGap)) {
    altGapEl.textContent = 'N/A';
    altInterpretEl.textContent = '';
  } else {
    const avgAlt = sentimentResults.avgAltGap;
    altGapEl.textContent = `${avgAlt.toFixed(2)}%`;

    let altLabel = '';
    if (avgAlt <= 25) altLabel = '🔥 Near Bull-Run Peaks (Euphoria)';
    else if (avgAlt <= 50) altLabel = '🟢 Healthy Correction (Neutral)';
    else if (avgAlt <= 75) altLabel = '🟠 Deep Correction (Fear / Opportunity)';
    else altLabel = '🔴 Capitulation (Extreme Fear / Bottom Forming)';

    altInterpretEl.textContent = altLabel;
    altInterpretEl.className =
      'interpret ' + (avgAlt <= 50 ? 'neutral' : avgAlt <= 75 ? 'bearish' : 'bearish');
  }

  // ✅ Altcoin Weakness Ratio
  ratioEl.textContent = !Number.isFinite(sentimentResults.ratio)
    ? '∞'
    : `${sentimentResults.ratio.toFixed(2)}×`;

  dominanceEl.textContent = `${sentimentResults.dominance} (Strong:${sentimentResults.strongCount}, Lag:${sentimentResults.lagCount})`;

  // ✅ Market Sentiment
  setSentimentUI(
    `${sentimentResults.sentimentEmoji} Market Sentiment: ${sentimentResults.sentiment} (${sentimentResults.sentimentScore})`,
    sentimentResults.sentimentClass
  );

  // ✅ Market Phase + Ladder
  const phaseInfo = determineMarketPhase(
    btcGap,
    sentimentResults.avgAltGap,
    sentimentResults.ratio,
    sentimentResults.strongCount,
    sentimentResults.lagCount
  );
  updatePhaseDisplay(phaseInfo);
  updatePhaseLadder(sentimentResults.ratio, btcGap);

  // ✅ Bitcoin Dominance (integrated here)
  try {
    const btcDominance = await fetchBTCdominance();
    if (btcDominance) {
      btcDomEl.textContent = `${btcDominance.toFixed(2)}%`;

      if (btcDominance > 55) {
        btcDomInterpret.textContent = "🔵 Bitcoin-led phase — alts still lagging.";
        btcDomInterpret.className = "interpret bearish";
      } else if (btcDominance >= 40 && btcDominance <= 55) {
        btcDomInterpret.textContent = "🟡 Mixed market — partial rotation ongoing.";
        btcDomInterpret.className = "interpret neutral";
      } else {
        btcDomInterpret.textContent = "🟢 Altseason — capital flowing into altcoins!";
        btcDomInterpret.className = "interpret bullish";
      }
    } else {
      btcDomEl.textContent = "—";
      btcDomInterpret.textContent = "Unable to fetch data.";
    }
  } catch (err) {
    console.error("BTC Dominance fetch failed:", err);
    btcDomEl.textContent = "—";
    btcDomInterpret.textContent = "Error fetching data.";
  }
      }

  
// wire controls
refreshNowBtn.addEventListener('click', ()=> { runAnalysis(true); });
scopeSelect.addEventListener('change', ()=> runAnalysis(true));
displaySelect.addEventListener('change', ()=> runAnalysis(true));
refreshSelect.addEventListener('change', ()=> {
  clearInterval(refreshTimer);
  const ms = Number(refreshSelect.value) * 1000;
  refreshTimer = setInterval(()=> runAnalysis(false), ms);
});

// initial run
runAnalysis(false);

// expose for debugging
window._sentiment_debug = {
  runAnalysis, fetchPages, computeGaps, deriveSentiment, loadCache, saveCache
};
</script>
</body>
</html>
