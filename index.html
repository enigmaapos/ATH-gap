<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Top 1000 Coins — ATH Gap Dashboard (CoinGecko)</title>
  <style>
    :root{
      --bg:#071022; --card:#0f1724; --muted:#9aa6b2; --accent:#38bdf8; --good:#22c55e; --bad:#ef4444;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,#041021 0%, #071022 100%); color:#e6eef6; padding:18px;}
    .wrap{max-width:1200px;margin:0 auto;}
    header{display:flex;align-items:center;gap:12px;justify-content:space-between;margin-bottom:14px}
    h1{font-size:20px;margin:0;color:var(--accent)}
    .sub{color:var(--muted);font-size:13px;margin-top:4px}
    .controls {display:flex;gap:8px;align-items:center;}
    select,input,button{background:var(--card);border:1px solid rgba(255,255,255,0.03);color:var(--muted);padding:8px;border-radius:8px;font-size:13px}
    input[type=number]{width:92px}
    button.primary{background:linear-gradient(90deg,#0ea5e9,#7dd3fc);color:#041022;border:none;font-weight:600}
    .card{background:var(--card);border-radius:12px;padding:12px;margin-bottom:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);border:1px solid var(--glass)}
    .small{font-size:13px;color:var(--muted)}
    .status{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .progress{height:10px;background:rgba(255,255,255,0.04);border-radius:999px;overflow:hidden;width:240px}
    .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#60a5fa);width:0%}
    table{width:100%;border-collapse:collapse;font-size:13px}
    thead th{position:sticky;top:0;background:rgba(3,7,18,0.8);backdrop-filter:blur(4px);z-index:2;padding:10px;text-align:left;color:var(--accent);font-weight:600;border-bottom:1px solid rgba(255,255,255,0.03)}
    tbody tr{border-bottom:1px solid rgba(255,255,255,0.02)}
    td{padding:10px;color:#dbeafe}
    td.sym{width:230px;display:flex;gap:10px;align-items:center}
    img.logo{width:20px;height:20px;border-radius:4px;object-fit:cover;box-shadow:0 2px 6px rgba(2,6,23,0.6)}
    .num{font-family: ui-monospace,SFMono-Regular,Menlo,monospace}
    .pct-good{color:var(--good);font-weight:600}
    .pct-bad{color:var(--bad);font-weight:600}
    .barWrap{height:10px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden;width:140px}
    .barFill{height:100%;background:linear-gradient(90deg,var(--good),#7ee787);width:0%}
    .muted{color:var(--muted);font-size:12px}
    .controls .muted{margin-left:6px}
    .center{display:flex;justify-content:center;align-items:center}
    .download{background:transparent;border:1px dashed rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:var(--muted)}
    @media (max-width:900px){
      td.sym{width:180px}
      .controls{flex-wrap:wrap}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Top 1000 Coins — ATH Gap Dashboard</h1>
        <div class="sub">CoinGecko data • calculates % below ATH and ROI to ATH • client-side caching + safe rate pacing</div>
      </div>

      <div class="controls">
        <label class="small muted">Max coins</label>
        <select id="maxCoins">
          <option value="250">Top 250</option>
          <option value="500">Top 500</option>
          <option value="750">Top 750</option>
          <option value="1000" selected>Top 1000</option>
        </select>

        <label class="small muted">Refresh</label>
        <select id="refreshSec">
          <option value="60">60s</option>
          <option value="120">120s</option>
          <option value="300">300s</option>
        </select>

        <button id="refreshBtn" class="primary">Refresh Now</button>
        <button id="downloadCsv" class="download">Download CSV</button>
      </div>
    </header>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
        <div class="status">
          <div class="small muted">Status:</div>
          <div id="statusText" class="small">Idle</div>

          <div class="small muted">•</div>
          <div class="small muted">Fetched:</div>
          <div id="fetchedCount" class="small">0</div>

          <div class="small muted">•</div>
          <div class="small muted">Last update:</div>
          <div id="lastUpdate" class="small">—</div>
        </div>

        <div style="display:flex;align-items:center;gap:10px">
          <div class="muted">Progress</div>
          <div class="progress" title="fetch progress"><i id="progressFill"></i></div>
        </div>
      </div>
      <div style="margin-top:10px" class="muted">Notes: This client-side dApp fetches pages of 250 coins from CoinGecko with a small delay between calls to avoid rate-limit. Cached results stored in localStorage for the selected refresh interval.</div>
    </div>

    <div class="card" id="tableCard">
      <table id="coinsTable" role="table">
        <thead>
          <tr>
            <th style="width:56px">#</th>
            <th style="width:280px">Coin</th>
            <th>Price (USD)</th>
            <th>ATH (USD)</th>
            <th style="width:120px">Below ATH</th>
            <th style="width:130px">ROI → ATH</th>
            <th style="width:160px">Progress to ATH</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

  </div>

  <script>
    (function(){
      // Config
      const COINGECKO_BASE = 'https://api.coingecko.com/api/v3';
      const PER_PAGE = 250;                // CoinGecko supports up to 250 per page
      const REQUEST_DELAY_MS = 1100;       // delay between page requests (1.1s) to be polite/avoid bursts
      const CACHE_KEY = 'cg_ath_cache_v1';
      const CACHE_INFO_KEY = 'cg_ath_cache_info_v1';

      // Elements
      const maxCoinsEl = document.getElementById('maxCoins');
      const refreshSecEl = document.getElementById('refreshSec');
      const refreshBtn = document.getElementById('refreshBtn');
      const downloadCsvBtn = document.getElementById('downloadCsv');
      const statusText = document.getElementById('statusText');
      const fetchedCountEl = document.getElementById('fetchedCount');
      const lastUpdateEl = document.getElementById('lastUpdate');
      const progressFill = document.getElementById('progressFill');
      const tbody = document.getElementById('tbody');

      // State
      let timerId = null;
      let lastFetchTimestamp = 0;
      let cacheTTLms = Number(refreshSecEl.value) * 1000;
      let cachedData = loadCache();

      function loadCache(){
        try{
          const raw = localStorage.getItem(CACHE_KEY);
          const infoRaw = localStorage.getItem(CACHE_INFO_KEY);
          const info = infoRaw ? JSON.parse(infoRaw) : null;
          if(!raw) return { list: null, info };
          const parsed = JSON.parse(raw);
          return { list: parsed, info };
        }catch(e){
          console.warn('cache load error', e);
          return { list:null, info:null };
        }
      }

      function saveCache(list){
        try{
          localStorage.setItem(CACHE_KEY, JSON.stringify(list));
          localStorage.setItem(CACHE_INFO_KEY, JSON.stringify({ ts: Date.now(), count: list.length }));
        }catch(e){
          console.warn('cache save error', e);
        }
        cachedData = loadCache();
      }

      // Utility: sleep
      const sleep = (ms) => new Promise(res => setTimeout(res, ms));

      // Build coin markets URL for a given page
      function marketsUrl(page, perPage=PER_PAGE){
        return `${COINGECKO_BASE}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${perPage}&page=${page}&sparkline=false&price_change_percentage=24h`;
      }

      // Fetch pages in sequence with delay (safe)
      async function fetchTopN(n){
        const pages = Math.ceil(n / PER_PAGE);
        let all = [];
        for(let p=1;p<=pages;p++){
          setStatus(`Fetching page ${p}/${pages} ...`);
          updateProgress((p-1)/pages);
          try{
            const res = await fetch(marketsUrl(p));
            if(!res.ok){
              throw new Error(`HTTP ${res.status}`);
            }
            const json = await res.json();
            all = all.concat(json);
            fetchedCountEl.textContent = all.length;
          }catch(err){
            console.error('fetch error page', p, err);
            // if rate-limited, break and return what we have
            setStatus(`Error fetching page ${p}: ${err.message}`);
            break;
          }
          // don't wait after last page
          if(p < pages) await sleep(REQUEST_DELAY_MS);
        }
        updateProgress(1);
        return all;
      }

      // Compute gap & roi for each coin item (coinGecko markets response)
      function computeMetrics(list){
        return list.map((c, idx) => {
          const price = parseFloat(c.current_price);
          const ath = parseFloat(c.ath);
          const belowPct = (!ath || ath === 0) ? null : ((ath - price) / ath) * 100;
          const roiPct = (!price || price === 0) ? null : ((ath - price) / price) * 100;
          return {
            rank: c.market_cap_rank || (idx+1),
            id: c.id,
            symbol: (c.symbol||'').toUpperCase(),
            name: c.name,
            image: c.image,
            price,
            ath,
            belowPct,
            roiPct
          };
        });
      }

      // Render table rows
      function renderTable(rows){
        // default sort: big gap first (desc)
        rows.sort((a,b) => (b.belowPct || 0) - (a.belowPct || 0));
        tbody.innerHTML = '';
        rows.forEach(r => {
          const tr = document.createElement('tr');
          const belowText = r.belowPct === null ? '—' : `${r.belowPct.toFixed(2)}%`;
          const roiText = r.roiPct === null ? '—' : `${r.roiPct.toFixed(2)}%`;
          const belowClass = (r.belowPct !== null && r.belowPct >= 0) ? 'pct-bad' : '';
          const roiClass = (r.roiPct !== null && r.roiPct >= 0) ? 'pct-good' : '';
          const progPct = (r.ath && r.ath>0) ? Math.min(100, (r.price / r.ath) * 100) : 0;

          tr.innerHTML = `
            <td class="num">${r.rank}</td>
            <td class="sym">
              <img class="logo" src="${r.image || ''}" alt="${r.symbol}" onerror="this.style.display='none'">
              <div style="display:flex;flex-direction:column">
                <div style="font-weight:600">${r.symbol} <span style="font-weight:400;color:var(--muted);font-size:12px;margin-left:8px">${r.name}</span></div>
                <div class="muted" style="font-size:12px">ID: ${r.id}</div>
              </div>
            </td>
            <td class="num">$${formatNumber(r.price, r.price<1?6:2)}</td>
            <td class="num">$${r.ath?formatNumber(r.ath,2):'—'}</td>
            <td class="${belowClass} num">${belowText}</td>
            <td class="${roiClass} num">${roiText}</td>
            <td>
              <div class="barWrap"><div class="barFill" style="width:${progPct}%"></div></div>
            </td>
          `;
          tbody.appendChild(tr);
        });
      }

      function formatNumber(n, digits=2){
        if(n === null || n === undefined || Number.isNaN(n)) return '—';
        return Number(n).toLocaleString(undefined, {maximumFractionDigits: digits});
      }

      function setStatus(txt){
        statusText.textContent = txt;
      }

      function updateProgress(frac){
        const pct = Math.round(frac * 100);
        progressFill.style.width = pct + '%';
      }

      // Main refresh logic with caching TTL
      async function refresh(force=false){
        try{
          const maxCoins = Number(maxCoinsEl.value);
          cacheTTLms = Number(refreshSecEl.value) * 1000;
          const cached = cachedData && cachedData.list;
          const cachedInfo = cachedData && cachedData.info;
          const now = Date.now();
          const validCache = cached && cachedInfo && ((now - (cachedInfo.ts || 0)) < cacheTTLms) && (cached.length >= maxCoins);

          if(validCache && !force){
            setStatus('Using cached data');
            fetchedCountEl.textContent = cached.length;
            lastUpdateEl.textContent = new Date(cachedData.info.ts).toLocaleString();
            const rows = computeMetrics(cached.slice(0, maxCoins));
            renderTable(rows);
            return;
          }

          setStatus('Fetching from CoinGecko...');
          updateProgress(0);
          const list = await fetchTopN(maxCoins);

          if(list && list.length){
            const rows = computeMetrics(list.slice(0, maxCoins));
            renderTable(rows);
            saveCache(list);
            fetchedCountEl.textContent = list.length;
            lastUpdateEl.textContent = new Date().toLocaleString();
            setStatus('Fetch complete');
            lastFetchTimestamp = Date.now();
          }else{
            setStatus('No data fetched');
          }
        }catch(err){
          console.error('refresh error', err);
          setStatus('Error: ' + (err && err.message ? err.message : 'unknown'));
        }
      }

      // CSV Export
      function exportCsv(){
        const rows = Array.from(tbody.querySelectorAll('tr')).map(tr => {
          const cells = tr.querySelectorAll('td');
          return [
            cells[0].innerText.trim(),
            cells[1].innerText.replace(/\n/g,' ').trim(),
            cells[2].innerText.replace('$','').trim(),
            cells[3].innerText.replace('$','').trim(),
            cells[4].innerText.trim(),
            cells[5].innerText.trim()
          ].join(',');
        });
        const header = 'Rank,Coin,Price USD,ATH USD,Below ATH %,ROI to ATH %';
        const csv = [header].concat(rows).join('\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `cg_ath_gap_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'_')}.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      // Initialize UI and auto refresh
      function startAutoRefresh(){
        const sec = Number(refreshSecEl.value);
        if(timerId) clearInterval(timerId);
        timerId = setInterval(()=>refresh(false), sec * 1000);
      }

      // Event listeners
      refreshBtn.addEventListener('click', ()=>refresh(true));
      refreshSecEl.addEventListener('change', ()=> {
        startAutoRefresh();
        // adjust cache TTL
        cacheTTLms = Number(refreshSecEl.value) * 1000;
      });
      maxCoinsEl.addEventListener('change', ()=>refresh(true));
      downloadCsvBtn.addEventListener('click', exportCsv);

      // Kick off initial load
      (async function init(){
        setStatus('Initializing...');
        // If we have cached data, render immediately then refresh in background
        if(cachedData && cachedData.list && cachedData.list.length){
          const rows = computeMetrics(cachedData.list.slice(0, Number(maxCoinsEl.value)));
          renderTable(rows);
          fetchedCountEl.textContent = cachedData.list.length;
          lastUpdateEl.textContent = cachedData.info ? new Date(cachedData.info.ts).toLocaleString() : '—';
          setStatus('Showing cached data — refreshing in background');
          // schedule a background refresh but don't force user to wait
          refresh(false);
        }else{
          await refresh(true);
        }
        startAutoRefresh();
      })();

      // expose for debugging (optional)
      window._cg_dashboard = { refresh, exportCsv };
    })();
  </script>
</body>
</html>
```0
